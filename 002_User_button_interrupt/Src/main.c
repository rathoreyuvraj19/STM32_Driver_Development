/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

#define RCC_BASE_ADDRESS 0x40023800UL

#define RCC_AHB1ENR  (RCC_BASE_ADDRESS + 0x30)

#define GPIOA_BASE_ADDRESS 0x40020000UL
#define GPIOD_BASE_ADDRESS 0x40020C00UL

#define GPIOA_MODER (GPIOA_BASE_ADDRESS + 0x00)
#define GPIOD_MODER (GPIOD_BASE_ADDRESS + 0x00)

#define GPIOA_PUPDR (GPIOA_BASE_ADDRESS + 0x0C)

#define GPIOA_IDR  (GPIOA_BASE_ADDRESS + 0x10)

#define GPIOD_ODR (GPIOD_BASE_ADDRESS + 0x14)

#define RCC_APB2ENR (RCC_BASE_ADDRESS + 0x44)

#define EXTI_BASE_ADDRESS 0x40013C00UL
#define EXTI_IMR (EXTI_BASE_ADDRESS + 0x00)
#define EXTI_RTSR (EXTI_BASE_ADDRESS + 0x08)
#define EXTI_PR (EXTI_BASE_ADDRESS + 0x14)

#define SYSCFG_BASE_ADDRESS 0x40013800UL
#define SYSCFG_EXTICR1 (SYSCFG_BASE_ADDRESS + 0x08)

#define NVIC_BASE_ADDRESS 0xE000E100UL
#define NVIC_ISER0 (NVIC_BASE_ADDRESS)

int main(void) {
	/* Loop forever */
	//1. Enable GPIOA peripheral
	uint32_t *pRCC_AHB1ENR = (uint32_t*) RCC_AHB1ENR;
	*pRCC_AHB1ENR |= (1 << 0);

	//2. Set pin PA0 as the input
	uint32_t *pGPIOA_MODER = (uint32_t*) GPIOA_MODER;
	*pGPIOA_MODER &= ~(3 << 0); //Setting PA0 as input
	//uint32_t *pGPIOA_IDR = (uint32_t*) GPIOA_IDR;

	//3. Enable GPIOD peripheral
	*pRCC_AHB1ENR |= (1 << 3);

	//4. Setup Pin PD12 as output
	uint32_t *pGPIOD_MODER = (uint32_t*) GPIOD_MODER;
	*pGPIOD_MODER |= (1 << 24); //Setting PD12 as output
	*pGPIOD_MODER |= (1 << 26); //Setting PD13 as output
	*pGPIOD_MODER |= (1 << 28); //Setting PD14 as output
	*pGPIOD_MODER |= (1 << 30); //Setting PD15 as output


	//5. Enable the interrupt peripheral peripheral
	uint32_t* pRCC_APB2ENR = (uint32_t*)RCC_APB2ENR;
	*pRCC_APB2ENR |= (1<<14);

	//6. Set EXT0 to pin PA0
	uint32_t* pSYSCFG_EXTICR1 = (uint32_t*)SYSCFG_EXTICR1;
	*pSYSCFG_EXTICR1 &= ~(15<<0);

	//7. Unmask EXTI0
	uint32_t* pEXTI_IMR = (uint32_t*)EXTI_IMR;
	*pEXTI_IMR |= (1<<0);

	//8. Setting EXTI_RTSR for rising edge trigger
	uint32_t* pEXTI_RTSR = (uint32_t*)EXTI_RTSR;
	*pEXTI_RTSR |= (1<<0);

	//9. Enable the IRQ corresponding to the EXTI0 in the Cortex M4 processor
	uint32_t* pNVIC_ISER0 = (uint32_t*)NVIC_ISER0;
	*pNVIC_ISER0 |= (1<<6);


	//10. Toggle the LED on button press
	uint32_t *pGPIOD_ODR = (uint32_t*) GPIOD_ODR;
	*pGPIOD_ODR |= (1 << 12);
	*pGPIOD_ODR |= (1 << 14);
//	*pGPIOD_ODR |= (1<<12); //Setting PA0 as input

	while(1);
//	while (1) {
//		if ((*pGPIOA_IDR) & 1) {
//			for (int i = 0; i < 100000; i++)
//				; //Debounce while press
//			*pGPIOD_ODR ^= (1 << 12);
//			*pGPIOD_ODR ^= (1 << 13);
//			*pGPIOD_ODR ^= (1 << 14);
//			*pGPIOD_ODR ^= (1 << 15);
//			while ((*pGPIOA_IDR) & 1)
//				; // Wait for the button hold high
//			for (int i = 0; i < 100000; i++)
//				; // Debounce after release
//		}
//	}
	for (;;)
		;
}

void EXTI0_IRQHandler(void) {
	uint32_t *pGPIOD_ODR = (uint32_t*) GPIOD_ODR;
	uint32_t *pGPIOA_IDR = (uint32_t*) GPIOA_IDR;
	uint32_t* pEXTI_IMR = (uint32_t*)EXTI_IMR;
	uint32_t* pEXTI_PR = (uint32_t*)EXTI_PR;


	//Mask the interrupt
	*pEXTI_IMR &= (1<<0);
	for (int i = 0; i < 100000; i++)
		;
	//Debounce while press
	*pGPIOD_ODR ^= (1 << 12);
	*pGPIOD_ODR ^= (1 << 13);
	*pGPIOD_ODR ^= (1 << 14);
	*pGPIOD_ODR ^= (1 << 15);
	while ((*pGPIOA_IDR) & 1)
		;
	// Wait for the button hold high
	for (int i = 0; i < 100000; i++)
		;
	// Debounce after release
	//Unmask the interrupt
	*pEXTI_IMR |= (1<<0);

	//*******Most important Clear the pending interrupt in the EXTI peripheral
	// To clear it we have to write 1 to it.
	*pEXTI_PR |= (1<<0);
}
